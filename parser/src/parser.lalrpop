// vim: ft=rust
use core::{RpNumber, Loc, RpModifier, RpPackage, Object, VersionReq};
use std::path::PathBuf;
use std::rc::Rc;
use super::ast::*;
use super::token::{self, Token};
use super::utils::*;

grammar<'input, 'object>(input_object: &'object Rc<Box<Object>>);

pub File: File<'input> = {
    <options:Loc<OptionDecl>*>
    <uses:Loc<Use>*>
    <decls:Loc<Decl>*> => File {
        options: options,
        uses: uses,
        decls: decls,
    },
};

Use: UseDecl<'input> = {
    "use" <package:Loc<Package>>
        <version_req:("@" Loc<VersionReq>)?>
        <alias:Loc<Alias>?>
    ";" => UseDecl {
        package: package,
        version_req: version_req.map(|v| v.1),
        alias: alias,
    },
};

Package: RpPackage = <parts:OneOrMore<".", Identifier>> => {
    RpPackage::new(parts.into_iter().map(ToOwned::to_owned).collect())
};

Decl: Decl<'input> = {
    <en:Loc<Enum>> => Decl::Enum(en),
    <interface:Loc<Interface>> => Decl::Interface(interface),
    <ty:Loc<Type>> => Decl::Type(ty),
    <tuple:Loc<Tuple>> => Decl::Tuple(tuple),
    <service:Loc<Service>> => Decl::Service(service),
};

Enum: EnumBody<'input> =
    <comment:"///"?>
    "enum" <name:TypeIdentifier> <ty:(":" Loc<TypeSpec>)?> "{"
      <variants:Loc<EnumVariant>*>
      <members:Loc<Member>*>
    "}" =>
{
    EnumBody {
        name: name,
        comment: comment.unwrap_or_else(Vec::new),
        ty: ty.map(|ty| ty.1),
        variants: variants,
        members: members,
    }
};

Interface: InterfaceBody<'input> =
    <comment:"///"?>
    "interface" <name:TypeIdentifier> "{"
      <members:Loc<Member>*>
      <sub_types:Loc<SubType>*>
    "}" =>
{
    InterfaceBody {
        name: name,
        comment: comment.unwrap_or_else(Vec::new),
        members: members,
        sub_types: sub_types,
    }
};

Type: TypeBody<'input> =
    <comment:"///"?>
    "type" <name:TypeIdentifier> "{"
      <members:Loc<Member>*>
    "}" =>
{
    TypeBody {
        name: name,
        comment: comment.unwrap_or_else(Vec::new),
        members: members,
    }
};

Tuple: TupleBody<'input> =
    <comment:"///"?>
    "tuple" <name:TypeIdentifier> "{"
      <members:Loc<Member>*>
    "}" =>
{
    TupleBody {
        name: name,
        comment: comment.unwrap_or_else(Vec::new),
        members: members,
    }
};

Service: ServiceBody<'input> =
    <comment:"///"?>
    "service" <name:TypeIdentifier> "{"
        <children:ServiceNested*>
    "}" =>
{
    ServiceBody {
        name: name,
        comment: comment.unwrap_or_else(Vec::new),
        children: children,
    }
};

ServiceNested: ServiceNested<'input> = {
    <comment:"///"?>
    <method:Loc<TypeIdentifier>?> <path:Loc<PathSpec>?> "{"
        <options:Loc<OptionDecl>*>
        <children:ServiceNested*>
    "}" => {
        ServiceNested::Endpoint {
            method: method,
            path: path,
            comment: comment.unwrap_or_else(Vec::new),
            options: options,
            children: children,
        }
    },

    <comment:"///"?>
    "returns" <status:Loc<Number>?> <produces:Loc<string>?> <ty:Loc<TypeSpec>?> ";" => {
        ServiceNested::Returns {
            comment: comment.unwrap_or_else(Vec::new),
            status: status,
            produces: produces,
            ty: ty,
            options: vec![],
        }
    },
    <comment:"///"?>
    "returns" <status:Loc<Number>?> <produces:Loc<string>?> <ty:Loc<TypeSpec>?> "{"
        <options:Loc<OptionDecl>*>
    "}" => {
        ServiceNested::Returns {
            comment: comment.unwrap_or_else(Vec::new),
            status: status,
            produces: produces,
            ty: ty,
            options: options,
        }
    },

    <comment:"///"?>
    "accepts" <accepts:Loc<string>?> <ty:Loc<TypeSpec>?> <alias:Loc<Alias>?> ";" => {
        ServiceNested::Accepts {
            comment: comment.unwrap_or_else(Vec::new),
            accepts: accepts,
            alias: alias,
            ty: ty,
            options: vec![],
        }
    },
    <comment:"///"?>
    "accepts" <accepts:Loc<string>?>  <ty:Loc<TypeSpec>?> <alias:Loc<Alias>?> "{"
        <options:Loc<OptionDecl>*>
    "}" => {
        ServiceNested::Accepts {
            comment: comment.unwrap_or_else(Vec::new),
            accepts: accepts,
            alias: alias,
            ty: ty,
            options: options,
        }
    },
};

Alias: &'input str = "as" <value:Identifier> => value;

FieldAlias: String = {
    "as" <value:Identifier> => value.to_owned(),
    "as" <value:string> => value,
};

PathSpec: PathSpec<'input> = {
    // escape needed to capture variables
    "`" <segments:OneOrMore<"/", PathSegment>> "`" => {
        PathSpec {
            segments: segments,
        }
    },

    // if spec is string, use as a single, literal segment
    <value:Loc<string>> => {
        PathSpec {
            segments: vec![PathSegment::Literal { value: value }],
        }
    },
};

PathSegment: PathSegment<'input> = {
    "{" <name:Loc<Identifier>> ":" <ty:Loc<TypeSpec>> "}" => {
        PathSegment::Variable { name: name, ty: ty }
    },
    <value:Loc<path_segment>> => {
        PathSegment::Literal { value: value }
    },
};

EnumVariant: EnumVariant<'input> =
    <comment:"///"?>
    <name:Loc<TypeIdentifier>>
    <argument:("=" Loc<Value>)?>
    ";" =>
{
    EnumVariant {
        name: name,
        comment: comment.unwrap_or_else(Vec::new),
        argument: argument.map(|a| a.1),
    }
};

pub Member: Member<'input> = {
    <comment:"///"?>
    <name:Identifier> <modifier:"?"?> ":" <ty:TypeSpec> <alias:Loc<FieldAlias>?> ";" => {
         let field = Field {
             modifier: modifier.map(|_| RpModifier::Optional).unwrap_or(RpModifier::Required),
             name: name,
             comment: comment.unwrap_or_else(Vec::new),
             ty: ty,
             field_as: alias,
         };

         Member::Field(field)
    },

    <option:OptionDecl> => {
         Member::Option(option)
    },

    <context:Identifier> "{{" <content:code> "}}" => {
        let content = strip_code_block(content);
        Member::Code(context, content)
    },

    <decl:Decl> => {
        Member::InnerDecl(decl)
    },
};

OptionDecl: OptionDecl<'input> = <name:Identifier> <values:OneOrMore<",", Loc<Value>>> ";" => OptionDecl {
    name: name,
    values: values,
};

SubType: SubType<'input> = {
    <comment:"///"?>
    <name:TypeIdentifier> "{"
        <members:Loc<Member>*>
    "}" => {
         SubType {
             name: name,
             comment: comment.unwrap_or_else(Vec::new),
             members: members,
         }
    },
};

pub Value: Value<'input> = {
    "[" <values:ZeroOrMore<",", Loc<Value>>> "]" => Value::Array(values),
    <string:string> => Value::String(string),
    <number:Number> => Value::Number(number),
    <true> => Value::Boolean(true),
    <false> => Value::Boolean(false),
    <identifier:Identifier> => Value::Identifier(identifier),
};

pub TypeSpec: Type = {
    "any" => Type::Any,
    "float" => Type::Float,
    "double" => Type::Double,
    "signed" <size:TypeBits?> => Type::Signed {
        size: size
    },
    "unsigned" <size:TypeBits?> => Type::Unsigned {
        size: size
    },
    "boolean" => Type::Boolean,
    "string" => Type::String,
    "bytes" => Type::Bytes,
    <name:Name> => Type::Name{
        name: name
    },
    "[" <inner:TypeSpec> "]" => Type::Array {
        inner: Box::new(inner)
    },
    "{" <key:TypeSpec> ":" <value:TypeSpec> "}" => Type::Map{
        key: Box::new(key),
        value: Box::new(value)
    },
};

Name: Name = {
    <prefix:(Identifier "::")?> <parts:OneOrMore<"::", TypeIdentifier>> => Name::Absolute {
        prefix: prefix.map(|p| p.0.to_owned()),
        parts: parts.into_iter().map(ToOwned::to_owned).collect(),
    },
    "::" <parts:OneOrMore<"::", TypeIdentifier>> => Name::Relative {
        parts: parts.into_iter().map(ToOwned::to_owned).collect(),
    },
};

TypeBits: usize = "/" <number:Number> => number.to_usize().unwrap_or(0usize);

/// Zero or more matching, separated by a token.
ZeroOrMore<Sep, T>: Vec<T> = {
    <value:OneOrMore<Sep, T>?> => {
        value.unwrap_or_else(|| vec![])
    }
};

/// One or more matching, separated by a token.
OneOrMore<Sep, T>: Vec<T> = {
     <values:(<T> Sep)*> <last:T> => {
        let mut values = values;
        values.push(last);
        values
    }
};

Loc<Inner>: Loc<Inner> = <s:@L> <inner:Inner> <e:@R> => {
    Loc::new(inner, (input_object.clone(), s, e))
};

extern {
    type Location = usize;
    type Error = token::Error;

    enum Token<'input> {
        TypeIdentifier => Token::TypeIdentifier(<&'input str>),
        Identifier => Token::Identifier(<&'input str>),
        Number => Token::Number(<RpNumber>),
        VersionReq => Token::VersionReq(<VersionReq>),
        "use" => Token::UseKeyword,
        "as" => Token::AsKeyword,
        "enum" => Token::EnumKeyword,
        "type" => Token::TypeKeyword,
        "interface" => Token::InterfaceKeyword,
        "tuple" => Token::TupleKeyword,
        "service" => Token::ServiceKeyword,
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
        "{" => Token::LeftCurly,
        "}" => Token::RightCurly,
        "{{" => Token::CodeOpen,
        "}}" => Token::CodeClose,
        code => Token::CodeContent(<&'input str>),
        string => Token::String(<String>),
        path_segment => Token::PathSegment(<String>),
        "[" => Token::LeftBracket,
        "]" => Token::RightBracket,
        ";" => Token::SemiColon,
        ":" => Token::Colon,
        "?" => Token::QuestionMark,
        "/" => Token::Slash,
        "=" => Token::Equals,
        "=>" => Token::HashRocket,
        "," => Token::Comma,
        "." => Token::Dot,
        "::" => Token::Scope,
        "any" => Token::AnyKeyword,
        "float" => Token::FloatKeyword,
        "double" => Token::DoubleKeyword,
        "signed" => Token::SignedKeyword,
        "unsigned" => Token::UnsignedKeyword,
        "boolean" => Token::BooleanKeyword,
        "string" => Token::StringKeyword,
        "bytes" => Token::BytesKeyword,
        true => Token::TrueKeyword,
        false => Token::FalseKeyword,
        "returns" => Token::ReturnsKeyword,
        "accepts" => Token::AcceptsKeyword,
        "*" => Token::Star,
        "@" => Token::At,
        "`" => Token::Tick,
        "///" => Token::DocComment(<Vec<&'input str>>),
    }
}
