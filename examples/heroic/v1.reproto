package heroic.v1;

use heroic.common as c;

type Sampling {
    // Unit of the sampling.
    //
    // This is used primarily to mess with gabriel
    unit?: TimeUnit;
    size: unsigned;
    extent?: unsigned;
}

enum SI {
  NANO = 3;
  MICRO = 2;
  MILLI = 10;

  serialized_as_name true;
}

enum TimeUnit {
  SECONDS("seconds", 1000);
  MINUTES("minutes", 60000);

  serialized_as number;

  // The name of the time unit
  name: string;
  // The number of the time unit
  number: double;

  java {{
    public double toMilliseconds() {
      return this.number;
    }
  }}
}

tuple Point {
  match {
    42 => Point(timestamp: 42, value: 41.2);
    n: unsigned => Point(timestamp: n, value: 42.0);
    p: Point => p;
  }

  timestamp: unsigned/64 as "TS";
  value: double;
}

tuple Event {
  timestamp: unsigned/64;
  payload?: any;
}

interface Samples {
  match {
    name: string => Samples.Points(name: name, data: []);
  }

  // Name of the current set of samples
  //
  // ```
  // This is an example code-block.
  // ```
  name: string;

  Points {
    name "points";

    // List of points
    data: [Point];
  }

  Events {
    name "events";

    // List of events
    data: [Event];
  }
}

type Query {
  query?: string;
  aggregation?: Aggregation;
  date?: c::Date;
  parameters?: {string: string};
}

interface Duration {
  Absolute {
    name "absolute";

    start: unsigned/64;
    end: unsigned/64;
  }
}

interface Aggregation {
  match {
    chain: [Aggregation] => Aggregation.Chain(chain: chain);
  }

  Sum {
    name "sum";

    sampling?: Sampling;
    size?: Duration;
    extent?: Duration;
  }

  Average {
    name "average";

    sampling?: Sampling;
    size?: Duration;
    extent?: Duration;
  }

  Chain {
    name "chain";

    chain: [Aggregation];
  }
}
